# Three.js WebGPU & TSL Ecosystem (JS/TS, r180+ and above)

## TSL Modules and Shader Helpers

- **TSL Textures (boytchev/tsl-textures)** - An open-source collection of procedural textures authored in Three.js Shading Language (TSL). It provides GPU-generated "shape" and noise textures at runtime (e.g. patterns like camouflage, clouds, etc.), requiring a dense mesh for displacement-type textures[\[1\]](https://boytchev.github.io/tsl-textures/#:~:text=Shape%20textures). The project is actively maintained (210★ on GitHub) and available on NPM[\[2\]](https://github.com/boytchev/tsl-textures#:~:text=,Star%20210). Notable features include **real-time generation** of textures entirely on the GPU via TSL functions and compatibility with Three r180+ on both WebGPU and WebGL backends (TSL can target WGSL or GLSL)[\[3\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=,Node%20System). This library enables reusable texture nodes that can be plugged into NodeMaterials for procedural materials.
- **TSLFX (verekia/tslfx)** - A **growing TSL shader toolkit** (94★) offering pre-built visual effects, utilities, and math primitives for NodeMaterials[\[4\]](https://github.com/verekia/tslfx#:~:text=,Star%2094)[\[5\]](https://github.com/verekia/tslfx#:~:text=Early,js%20Shading%20Language%20%28TSL). TSLFX includes **VFX "primitives"** like an impact() shockwave effect (with time uniform for animated impact) and others that can be combined into more complex compositions[\[6\]](https://github.com/verekia/tslfx#:~:text=import%20,from%20%27tslfx)[\[7\]](https://github.com/verekia/tslfx#:~:text=Primitives%20are%20basic%20single%20effects,to%20see%20how%20it%20works). It also bundles **SDF (Signed Distance Function) nodes** (e.g. sdCircle, sdHeart, etc., ported from Inigo Quilez) for procedural shape generation[\[8\]](https://github.com/verekia/tslfx#:~:text=SDFs). Designed for Three r180+, it works with the experimental WebGPURenderer (and even falls back to WebGL via Three's internal WGSL→GLSL node transpilation)[\[9\]](https://github.com/verekia/tslfx#:~:text=Early,js%20Shading%20Language%20%28TSL). The library is MIT-licensed and updated frequently (100+ commits); it provides both vanilla and React examples for integration[\[10\]](https://github.com/verekia/tslfx#:~:text=The%20effects%20work%20with%20the,js%20or%20any%20other%20wrapper)[\[6\]](https://github.com/verekia/tslfx#:~:text=import%20,from%20%27tslfx). _Notable:_ All effects use TSL nodes (so they benefit from renderer-agnostic output). For instance, combining multiple TSLFX effects is as simple as using their exported nodes and uniforms in a custom NodeMaterial[\[6\]](https://github.com/verekia/tslfx#:~:text=import%20,from%20%27tslfx)[\[11\]](https://github.com/verekia/tslfx#:~:text=const%20ImpactVFX%20%3D%20%28%29%20%3D,impact%28%29%2C).
- **Built-in Three.js NodeMaterial & Nodes** - Three.js itself introduced the **Three Shader Language (TSL)** as of r180, which underpins all NodeMaterial classes (e.g. MeshStandardNodeMaterial, MeshBasicNodeMaterial). TSL allows writing shader logic in JS/TS instead of raw GLSL, and it automatically outputs WGSL or GLSL as needed for WebGPU or WebGL[\[3\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=,Node%20System). The core library provides a rich set of nodes/functions out-of-the-box - from textures and UV transforms to math ops and lighting nodes. For example, mixing two texture colors with a detail map is one-liner TSL (material.colorNode = texture(colorMap).mul(detailMap)) instead of manual GLSL injection[\[12\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=import%20,from%20%27three%2Ftsl). TSL ensures common sub-expressions (like world positions, normals) are computed only once and shared across nodes[\[13\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=Another%20important%20feature%20of%20a,declare%20and%20include%20it%20once). It also supports **advanced lighting models** (all standard PBR and toon/matcap materials have node equivalents) and can seamlessly incorporate custom code via code() or fn() nodes. Because TSL is fully integrated, many community modules now build on it - for instance, nodes for parallax mapping, toon shading, etc., can be created by extending Node classes. **Compatibility:** NodeMaterials currently require WebGPURenderer (WebGLRenderer support was removed as of r172)[\[14\]](https://discourse.threejs.org/t/what-is-going-on-with-nodematerials-all-the-examples-are-gone/66451#:~:text=gone%20discourse,WebGPURenderer%2C%20with%20a%20heavy), but TSL is designed to be renderer-agnostic in the long term. The Three.js repo's wiki and examples provide a _List of Nodes_ and conversion guides[\[15\]](https://github.com/brunosimon/three.js-tsl-template#:~:text=,TSL%20textures%20%28demos).
- **NodeGraph Editor Tools (Open Source)** - Several community-driven **visual shader editors** for TSL have emerged:
- _TSL Editor (bhushan6/tsl-editor)_ - A browser-based node editor for constructing TSL material graphs[\[16\]](https://discourse.threejs.org/t/node-editor-for-tsl/76355#:~:text=I%20am%20working%20on%20Node,com%2FBhushanwtf%2Fstatus%2F1877676492509085767%3Ft%3D0lMHj0NQP7u7_GaE1Tngdw%26%20s%3D19). It's in early development (26★) with a live demo at tsl-editor.vercel.app[\[17\]](https://discourse.threejs.org/t/node-editor-for-tsl/76355#:~:text=s%3D19%20x). Currently it supports basic nodes and previewing results; an upcoming feature is exporting the graph to code (the author stores the node layout as a comment in the exported JS for round-trip editing)[\[18\]](https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387#:~:text=Alpha%20release%2C%20hoping%20for%20othr,setup%20in%20the%20image%E2%80%99s%20metadata). This tool is built on a fork of the NODL library for the node UI and is open-source (MIT)[\[19\]](https://discourse.threejs.org/t/node-editor-for-tsl/76355#:~:text=bhushan6%20%20March%204%2C%202025%2C,7%3A00am%20%206). _Compatibility:_ Targets Three r180+ NodeMaterials. It's a helpful helper for those who prefer a visual approach to TSL.
- _Three.js Visual Node Editor (bandinopla/three.js-visual-node-editor)_ - Another open-source graph editor (48★) for Three TSL[\[20\]](https://github.com/bandinopla/three.js-visual-node-editor#:~:text=,Star%2048)[\[21\]](https://github.com/bandinopla/three.js-visual-node-editor#:~:text=MIT%20license). Released in alpha (as of Mar 2025), it allows users to create shader node graphs visually and **export them as JavaScript files** using TSL nodes[\[18\]](https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387#:~:text=Alpha%20release%2C%20hoping%20for%20othr,setup%20in%20the%20image%E2%80%99s%20metadata). The exported file contains the TSL code to recreate the material, with the node layout embedded in comments for re-importing, similar to how tools like ComfyUI store graphs[\[22\]](https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387#:~:text=Alpha%20release%2C%20hoping%20for%20othr,setup%20in%20the%20image%E2%80%99s%20metadata)[\[23\]](https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387#:~:text=can%20have%20this%20finished%20faster%21,setup%20in%20the%20image%E2%80%99s%20metadata). This editor aims to include a library of pre-made node setups/shaders for quick starts (e.g. common material templates)[\[24\]](https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387#:~:text=Thanks%20Mr,to%20write%20the%20TSL%20code)[\[25\]](https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387#:~:text=bandinopla%20%20April%201%2C%202025%2C,5%3A14pm%20%207). It's also MIT-licensed and supports Three's WebGPU NodeMaterial system. While not as mature as commercial tools, these open editors indicate a growing ecosystem for node-based shader authoring in Three.js.

## Post-Processing Libraries (WebGPU/TSL)

- **Three.js PostProcessing (Core)** - Alongside TSL, Three.js introduced a new post-processing system compatible with WebGPU. The class THREE.PostProcessing (available in examples) acts as an analogue to EffectComposer, allowing you to chain render passes using NodeMaterials. It supports **multiple render targets (MRT)** via TSL's mrt() and pass() nodes[\[26\]](https://discourse.threejs.org/t/three-js-webgpu-post-processing-effects/87390#:~:text=robotbobby%20%20October%2012%2C%202025%2C,2%3A05pm%20%203). For example, a recent Three.js example demonstrates GTAO (ground-truth ambient occlusion) on WebGPU by rendering scene depth and normals to textures in one pass, then applying an AO post effect in a second pass - all configured with NodeMaterial code. TSL provides built-in nodes like viewportLinearDepth() and normalView to access G-buffer data easily[\[27\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=manage%20the%20rendering%20process%20as,order.%20%2A%20Integrated%20Compute%20Shaders). There's also a ready TSL node for a Gaussian blur (gaussianBlur()) which internally performs a dual-pass blur when used, either as a material node or a post effect[\[28\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=,beauty%20what%20has%20already%20been). **Notable:** Because TSL nodes can manage their own render steps, complex effects can be achieved with surprisingly little code (e.g. a blur node can trigger its own ping-pong render passes under the hood[\[29\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=,depth%20what%20has%20already%20been)). While still experimental, this core post-processing stack is evolving rapidly with WebGPU - **by Three r182+ we have basic bloom, depth-of-field, AO, etc., working in WebGPU via TSL node graphs** (as seen in examples like webgpu_postprocessing_ao.html). Developers can also write custom post effects in TSL (or even WGSL directly, though TSL greatly simplifies uniform/binding setup[\[30\]](https://discourse.threejs.org/t/how-to-use-custom-shaders-in-webgpu/53343#:~:text=forum%20discourse,bindings%20for%20uniforms%20vertex)).
- **R3F WebGPU Post-Processing Starter** - The React Three Fiber community has put together examples of using post-effects with WebGPU. A notable one is **Anderson Mancini's R3F WebGPU Post Processing demo** (GitHub: ektogamat/r3f-webgpu-starter, 185★)[\[31\]](https://github.com/ektogamat/r3f-webgpu-starter#:~:text=,Star%20185)[\[32\]](https://github.com/ektogamat/r3f-webgpu-starter#:~:text=Image%3A%20screenshot). This project (updated mid-2025) shows how to integrate Three's new PostProcessing with R3F, demonstrating a simple scene with bloom and other effects on WebGPU. It uses TSL under the hood for the shader logic of effects. The live demo[\[33\]](https://github.com/ektogamat/r3f-webgpu-starter#:~:text=A%20very%20simple%20scene%20to,See%20the%20demo%20here) showcases that **multiple passes** (scene render, blur, etc.) can run on WebGPU via R3F's &lt;Canvas&gt; when configured to use WebGPURenderer. This starter also provides boilerplate for falling back to WebGL if WebGPU is unavailable, and how to update it in a React context. While not a standalone library, it's a helpful **template/guide** for anyone looking to do post-processing in React with WebGPU. (It essentially wraps Three's core PostProcessing in a React-friendly manner.)
- **PMND.rs PostProcessing Library** - The popular postprocessing library by pmndrs (formerly van Ruesc) is a well-established post-effect toolkit for Three (with effects like SSAO, god-rays, depth of field, etc.). _Current status:_ As of late 2025, the pmndrs/postprocessing package is still primarily targeting WebGL and has limited WebGPU support. There is ongoing work to make it WebGPU-compatible - for instance, an AO effect N8AO notes "not yet compatible with WebGPU, but will be in the future (perhaps version 2.0)"[\[34\]](https://www.npmjs.com/package/n8ao?activeTab=dependents#:~:text=n8ao%20,2.0%20perhaps). The maintainers have expressed that WebGPU's different shader model (WGSL and bindgroups) will require a substantial refactor or use of Three's Nodes. In the interim, developers who need advanced effects can either use core-TSL examples or hybrid approaches. **In summary:** pmndrs/postprocessing is a robust library (8k★) to watch - it's expected to add WebGPU/TSL compatibility, but as of now one should use the Three.js native PostProcessing or custom TSL passes for WebGPU projects.

## Compute & GPGPU Libraries

One of WebGPU's biggest advantages is **compute shaders**, and Three's Node system exposes this via TSL:

- **Integrated GPU Compute via TSL** - Three.js NodeMaterials can include compute shader stages using the compute() function in TSL, which runs on the GPU during rendering[\[35\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=%2F%2F%20%20so%20unaffected%20vertices,count)[\[36\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=Next%2C%20we%E2%80%99ll%20create%20a%20storage,in%20the%20context%20of%20TSL). This enables general-purpose GPU computations (GPGPU) in JS without writing WGSL directly. For example, the _"Interactive Text Destruction"_ demo by L. Armand (Codrops, Jul 2025) uses a TSL **compute shader** to animate thousands of text mesh vertices on WebGPU[\[37\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=The%20effect%20we%E2%80%99re%20going%20to,deformations%20in%20a%20dynamic%20way)[\[38\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=const%20initial_position%20%3D%20storage%28%20text_geo,count). The code defines storage buffers for vertex data (storage(geometry.attributes.position, "vec3", count)) and a TSL compute() function that updates each vertex's position over time (applying a spring physics formula)[\[35\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=%2F%2F%20%20so%20unaffected%20vertices,count). This compute pass runs every frame, separate from the render fragment shader, achieving an interactive GPU-driven explosion effect. The project's source on GitHub shows how TSL can be used for particle-like physics entirely in the browser GPU[\[37\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=The%20effect%20we%E2%80%99re%20going%20to,deformations%20in%20a%20dynamic%20way)[\[38\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=const%20initial_position%20%3D%20storage%28%20text_geo,count). This pattern - using storage() and compute nodes - can be applied to many scenarios: particle systems, flocking simulations, fluid solvers, etc., all in Three's abstraction.
- **GPGPU Particle Systems** - Early experiments and tutorials demonstrate massive particle counts with WebGPU. A WawaSensei tutorial _"GPGPU Particles with TSL & WebGPU"_ walks through creating hundreds of thousands of particles that form 3D shapes, using a TSL compute shader to update positions each frame[\[39\]](https://wawasensei.dev/courses/react-three-fiber/lessons/tsl-gpgpu#:~:text=GPGPU%20particles%20with%20TSL%20%26,TSL%29%20and%20WebGPU). The approach uses a float texture or storage buffer for particle state and a NodeMaterial to render points, updating their coords via a compute node. While not (yet) packaged as a plug-and-play library, these examples serve as reference implementations for a future Three.js _GPUParticles module_. We anticipate that as WebGPU matures, dedicated JS libraries for fluid dynamics, physics, AI, etc., will appear - likely built on the foundations of Three's TSL compute or lower-level frameworks like **GPU.js** (for data-parallel compute) or **TensorFlow.js with WebGPU** for ML. **In the interim**, Three.js developers can leverage TSL to incorporate compute kernels in their apps now, with the convenience of writing them in JS. (Outside of Three, note that pure WebGPU frameworks like **Babylon.js** also allow compute shaders, and standalone demos like "particle-life" simulations[\[40\]](https://lisyarus.github.io/blog/posts/particle-life-simulation-in-browser-using-webgpu.html#:~:text=Particle%20Life%20simulation%20in%20browser,produce%20fun%20simulations%20like%20this) show what's possible - but those are custom engines or raw API usage.)
- **BatchedMesh & Advanced Rendering** - While not GPGPU in the traditional sense, WebGPU's capabilities enable new Three.js utilities like BatchedMesh (introduced experimentally around r173). **BatchedMesh** automatically merges many objects into one GPU draw call, and can even leverage compute shaders to dynamically batch on the fly[\[41\]](https://discourse.threejs.org/t/dynamic-batching-using-webgpu/55146#:~:text=forum%20discourse,we%20want%20to%20merging%20meshes). A Codrops article (Wael Yasmina, 2025) showcases using BatchedMesh with WebGPURenderer for rendering **thousands of objects** efficiently, combined with a TSL postprocessing bloom effect[\[42\]](https://tympanus.net/codrops/2024/10/30/interactive-3d-with-three-js-batchedmesh-and-webgpurenderer/#:~:text=In%20this%20article%2C%20I%27ll%20walk,processing%20effects). The ability to run compute for batching means transformation updates or frustum culling could be done on GPU. This is an emerging area - not quite a separate library, but part of Three's WebGPU enhancements - that JS devs can tap into for performance. It underscores that WebGPU isn't just about shaders; it's about moving more work to the GPU (animation, culling, etc.). We expect Three.js to continue adding such utilities (e.g. compute-driven instancing, particle physics helpers) on top of TSL.

## Scene Graphs and Templates (WebGPU Integrations)

- **React Three Fiber (R3F)** - The popular React renderer for Three.js fully supports WebGPU and TSL as of React-Three-Fiber v9 (React 19). R3F now allows using Three's WebGPURenderer in a &lt;Canvas&gt; by providing an async gl callback. The R3F v9 docs include a WebGPU setup example: extending the three/webgpu module and returning a new THREE.WebGPURenderer from the Canvas' gl prop (with await renderer.init() since WebGPU must initialize asynchronously)[\[43\]](https://r3f.docs.pmnd.rs/tutorials/v9-migration-guide#webgpu#:~:text=Recent%20Three,prop%20to%20return%20a%20promise)[\[44\]](https://r3f.docs.pmnd.rs/tutorials/v9-migration-guide#webgpu#:~:text=export%20default%20%28%29%20%3D,meshBasicNodeMaterial). This integration means you can declare &lt;meshStandardNodeMaterial /&gt; or any NodeMaterial as JSX and have it render with WebGPU seamlessly[\[45\]](https://r3f.docs.pmnd.rs/tutorials/v9-migration-guide#webgpu#:~:text=import%20,three%2Ffiber)[\[46\]](https://r3f.docs.pmnd.rs/tutorials/v9-migration-guide#webgpu#:~:text=await%20renderer.init%28%29%20return%20renderer%20%7D%7D,mesh). All the usual R3F goodies (drei, react-postprocessing, etc.) can work if they are compatible with the NodeMaterial system. In practice, many community projects have started using R3F + WebGPU for experiments. For instance, the aforementioned R3F postprocessing demo runs inside Next.js 15 with R3F v9[\[47\]](https://blog.loopspeed.co.uk/react-three-fiber-webgpu-typescript#:~:text=1)[\[48\]](https://blog.loopspeed.co.uk/react-three-fiber-webgpu-typescript#:~:text=export%20default%20WebGPUCanvas%3B). **Compatibility notes:** You may need to polyfill or adjust for top-level await (Three's WebGPU capability-check uses it) in bundlers like Vite/Next - as documented by ecosystem test suites[\[49\]](https://github.com/verekia/three-gpu-ecosystem-tests#:~:text=Non)[\[50\]](https://github.com/verekia/three-gpu-ecosystem-tests#:~:text=Top). But overall, R3F v9 proves that **declarative Three + WebGPU is production-feasible**, given Chrome's stable WebGPU and other browsers catching up.
- **Threlte (Svelte + Three)** - Threlte version 8 (for SvelteKit) also provides integration with WebGPU and TSL. The Threlte docs show that switching to WebGPU is as simple as importing WebGPURenderer from three/webgpu and supplying it via the &lt;Canvas createRenderer={...}&gt; prop[\[51\]](https://threlte.xyz/docs/learn/advanced/webgpu#:~:text=To%20use%20the%20Three,replace%20the%20default%20WebGL%20renderer)[\[52\]](https://threlte.xyz/docs/learn/advanced/webgpu#:~:text=import%20,script). Minimal changes are required - essentially the same pattern as R3F. Threlte's extend(THREE) utility can register NodeMaterial classes for use in Svelte components[\[53\]](https://threlte.xyz/docs/learn/advanced/webgpu#:~:text=import%20,as%20THREE%20from%20%27three%2Fwebgpu), after which you can use &lt;mesh basicNodeMaterial={...} /&gt; in Svelte JSX. The Threlte team does caution that WebGPU in Three is not yet for critical production use (due to upstream breaking changes)[\[54\]](https://threlte.xyz/docs/learn/advanced/webgpu#:~:text=The%20WebGPU%20specification%20is%20still,recommend%20using%20WebGPU%20in%20production). But they have tested it: a SvelteKit + Threlte example with a large static scene (3000 objects) shows correct rendering with WebGPU and even performance gains. Threlte also supports **reactive uniforms and props** flowing into NodeMaterials. In summary, Svelte developers today can experiment with WebGPU just like React developers can.
- **Starter Kits and Templates** - Several boilerplates exist to kickstart projects:
- _Bruno Simon's TSL Starter_ - Bruno (of Three.js Journey) created a minimalist **three.js-tsl-template** repository (76★) to help developers learn TSL[\[55\]](https://github.com/brunosimon/three.js-tsl-template#:~:text=Three)[\[56\]](https://github.com/brunosimon/three.js-tsl-template#:~:text=Stars). It uses Vite and includes links to official docs and a list of nodes[\[15\]](https://github.com/brunosimon/three.js-tsl-template#:~:text=,TSL%20textures%20%28demos). While not focused on WebGPU per se, it targets Three r180+ so WebGPURenderer is available. This is great for experimenting with NodeMaterials in a simple environment.
- _Wass08's R3F WebGPU Starter_ - A small template (React + Vite, 6★) that sets up R3F with WebGPURenderer out of the box[\[57\]](https://github.com/wass08/r3f-webgpu-starter#:~:text=)[\[58\]](https://github.com/wass08/r3f-webgpu-starter#:~:text=React%20Three%20Fiber%20,Starter). It's a barebones scene ready for adding content. Another similar project by Zander (ektogamat) was mentioned earlier, oriented around including post-processing.
- _Three.js Examples_ - The official three.js examples now include many WebGPU + Nodes demos (found under examples/webgpu_\*). Notable ones: **webgpu_rtt** (render-to-texture with TSL), **webgpu_water** (water shader using NodeMaterial), **webgpu_instancing** (using NodeMaterial to handle instance uniforms), etc. These can serve as templates for specific use cases. Each example lists the minimum Three version required (generally r17x+).
- _Ecosystem Test Suite_ - Developer _Verekia_ compiled a **three-gpu-ecosystem-tests** repo to verify using WebGPURenderer and a simple TSL shader across frameworks (Vanilla, R3F, Threlte, various Next.js setups)[\[59\]](https://github.com/verekia/three-gpu-ecosystem-tests#:~:text=This%20is%20a%20collection%20of,React%20Three%20Fiber%2C%20and%20Threlte)[\[60\]](https://github.com/verekia/three-gpu-ecosystem-tests#:~:text=TSL%20node%2C%20and%20a%20test,React%20Three%20Fiber%2C%20and%20Threlte). All tests are green as of Three r173, indicating that **most major frameworks now play nicely with WebGPU** given some config tweaks. This gives confidence that choosing React or Svelte for a WebGPU project is a matter of preference, not limitation.

## Commercial & Closed-Source Tools

- **NodeToy (Online Shader Editor)** - _NodeToy_ is a polished cloud-based shader editor aimed at Three.js/R3F users[\[61\]](https://nodetoy.co/#:~:text=Built%20for%20ThreeJS%20%26%20React). It's currently in open beta (free to use) and provides a **visual node-based interface** with 150+ nodes for creating materials[\[62\]](https://nodetoy.co/#:~:text=Massive%20toolbox). NodeToy stands out for its user-friendly web UI (similar to Unity's Shader Graph or Unreal's Material Editor) and its ability to **publish and share shader graphs**. Creators can fork public shaders, learn from examples, and iterate rapidly. The tool is tightly integrated with Three.js: NodeToy can export shaders that work as Three.js materials. Specifically, the NodeToy team provides an NPM package @nodetoy/three-nodetoy (MIT-licensed) which allows loading NodeToy-created materials in your project[\[63\]](https://github.com/NodeToy/three-nodetoy#:~:text=three)[\[64\]](https://github.com/NodeToy/three-nodetoy#:~:text=import%20,nodetoy). You simply copy the provided URL or data blob of your shader from the NodeToy app and use new NodeToyMaterial({ url: "..." }) to get a Three.js Material[\[65\]](https://github.com/NodeToy/three-nodetoy#:~:text=Declare%20your%20material%3A)[\[66\]](https://github.com/NodeToy/three-nodetoy#:~:text=Simple%20example%3A). Under the hood, this generates a ShaderMaterial or NodeMaterial (NodeToy currently outputs raw GLSL, since it targets Three r143+ which predates TSL). NodeToy supports **dynamic uniforms** like time - developers just call a NodeToyMaterial.tick() each frame to update those[\[67\]](https://github.com/NodeToy/three-nodetoy#:~:text=If%20your%20materials%20are%20dynamic,for%20more%20information)[\[68\]](https://github.com/NodeToy/three-nodetoy#:~:text=Update%20Time%20%2F%20Dynamic%20uniforms). While the NodeToy application is closed-source (and likely to have a commercial model in the future), the integration libraries are open and free. Pricing has not been announced as it's in beta, but the service may adopt a SaaS model for pro features or private shaders. In terms of WebGPU: NodeToy doesn't yet export WGSL/TSL directly, but you can still use NodeToy shaders in WebGPU by feeding the GLSL into Three's WebGPURenderer - Three will internally convert it via WGSL transpilation (though this path may not cover all features). As Three's Node system grows, NodeToy might also support exporting TSL. Overall, NodeToy is a **powerful visual tool** to create Three-compatible shaders without coding, greatly accelerating material development for those willing to use a closed cloud solution[\[69\]](https://nodetoy.co/#:~:text=ImageImage)[\[61\]](https://nodetoy.co/#:~:text=Built%20for%20ThreeJS%20%26%20React).
- **Material Authoring Tools** - _Polygonjs_ is a node-based 3D editor (inspired by Houdini) that deserves mention. It's built on Three.js and offers visual programming for geometry, materials, particles, and post FX[\[70\]](https://discourse.threejs.org/t/nodematerial-visual-editor/12479#:~:text=gui%20%20February%203%2C%202020%2C,2%3A16pm%20%202)[\[71\]](https://discourse.threejs.org/t/nodematerial-visual-editor/12479#:~:text=Polygonjs%20also%20has%20a%20visual,is%20heavily%20inspired%20by%20Houdini). Polygonjs was free for personal use with optional paid licenses for support. Uniquely, it recently open-sourced (MIT) its engine core[\[72\]](https://github.com/polygonjs/polygonjs#:~:text=Polygonjs)[\[73\]](https://github.com/polygonjs/polygonjs#:~:text=Polygonjs%20helps%20creating%203D%20interactives,web%2C%20without%20having%20to%20code). However, **WebGPU status:** as of 2025, Polygonjs's shader system uses classic GLSL (it has a "GL" node context for writing custom GLSL code)[\[74\]](https://github.com/polygonjs/polygonjs#:~:text=,nodes%20set%20up%20post%20processing). It has not yet integrated TSL or WebGPU features, so materials created in Polygonjs are running on WebGL. That said, its **visual material editor** can export Three.js shader code, and it could potentially adopt TSL down the line. If your project doesn't strictly require WebGPU today, Polygonjs is a very robust tool for designing interactive scenes visually, with the option to export them as code or even use the Polygonjs runtime in your app. It even supports plugins (including physics, mapbox, etc.) and could be leveraged to prototype effects which you then manually convert to TSL. Polygonjs's development shows the direction of travel: more **node-based creation** in the JS ecosystem. As WebGPU stabilizes, we may see Polygonjs v2 or others incorporate it (the maintainers have indicated interest in WebGPU when it's production-ready). In summary, **Polygonjs (commercial editor)** is worth knowing, but for pure WebGPU+TSL projects you might stick to the lighter tools mentioned above until Polygonjs adds support.
- **Babylon.js Node Material Editor** - (Not Three.js, but notable in JS ecosystem.) Babylon.js is another popular engine which has WebGPU as a first-class citizen (Babylon v6+ defaults to WebGPU). Babylon offers a **Node Material Editor** (NME) as a web tool for visually creating shaders for Babylon engine[\[75\]](https://doc.babylonjs.com/features/featuresDeepDive/materials/node_material/nodeMaterial#:~:text=Node%20Material%20,Node%20Material%20allows%20you). It's closed-source but free to use, and one can export the node graphs as code or JSON. While Babylon's node materials are conceptually similar to Three's NodeMaterials, the systems aren't directly compatible. We mention it as an aside: if one is exploring WebGPU in JS beyond Three, Babylon's NME is a mature option (with features like live preview, code export, and even a library of nodes). However, it outputs shaders for Babylon's engine (in GLSL or WGSL form) and cannot be used for Three.js without conversion. Given the question's focus, Babylon/NME can be **excluded** from your Three.js project considerations, but it highlights that the **trend of visual shader tools** is happening across engines.

Finally, it's worth noting that the **Three.js dev team (led by @sunag for Nodes)** is actively improving TSL and WebGPU support each release. The ecosystem around it - from open-source libraries like TSLTextures/TSLFX to commercial editors like NodeToy - is growing quickly in 2024-2025. With Three r180+ you're at the cutting edge: you can write high-level shader logic in TypeScript, run compute kernels on the GPU, and use advanced rendering techniques once limited to engine internals - all in the browser. The community is still discovering best practices, so expect these tools and libraries to evolve. But as of late 2025, the stack described above represents the **most recent, actively maintained, and JS-centric resources** for WebGPU and TSL in Three.js[\[59\]](https://github.com/verekia/three-gpu-ecosystem-tests#:~:text=This%20is%20a%20collection%20of,React%20Three%20Fiber%2C%20and%20Threlte)[\[60\]](https://github.com/verekia/three-gpu-ecosystem-tests#:~:text=TSL%20node%2C%20and%20a%20test,React%20Three%20Fiber%2C%20and%20Threlte). Each will help you push the limits of real-time 3D graphics on the web. Enjoy experimenting with this next-gen workflow!

**Sources:** Key information was gathered from official three.js documentation and wiki[\[76\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=With%20,look%20like%20this)[\[27\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=manage%20the%20rendering%20process%20as,order.%20%2A%20Integrated%20Compute%20Shaders), community forums and tutorials (Three.js discourse, Codrops)[\[37\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=The%20effect%20we%E2%80%99re%20going%20to,deformations%20in%20a%20dynamic%20way)[\[39\]](https://wawasensei.dev/courses/react-three-fiber/lessons/tsl-gpgpu#:~:text=GPGPU%20particles%20with%20TSL%20%26,TSL%29%20and%20WebGPU), and the GitHub repositories of the libraries and tools mentioned (stars/updates as of Oct 2025)[\[2\]](https://github.com/boytchev/tsl-textures#:~:text=,Star%20210)[\[77\]](https://github.com/verekia/tslfx#:~:text=MIT%20license). Each tool listed includes a link to its code or website for further exploration.

[\[1\]](https://boytchev.github.io/tsl-textures/#:~:text=Shape%20textures) boytchev.github.io

<https://boytchev.github.io/tsl-textures/>

[\[2\]](https://github.com/boytchev/tsl-textures#:~:text=,Star%20210) GitHub - boytchev/tsl-textures: A collection of Three.js Shading Language (TSL) textures

<https://github.com/boytchev/tsl-textures>

[\[3\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=,Node%20System) [\[12\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=import%20,from%20%27three%2Ftsl) [\[13\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=Another%20important%20feature%20of%20a,declare%20and%20include%20it%20once) [\[27\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=manage%20the%20rendering%20process%20as,order.%20%2A%20Integrated%20Compute%20Shaders) [\[28\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=,beauty%20what%20has%20already%20been) [\[29\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=,depth%20what%20has%20already%20been) [\[76\]](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#:~:text=With%20,look%20like%20this) Three.js Shading Language · mrdoob/three.js Wiki · GitHub

<https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language>

[\[4\]](https://github.com/verekia/tslfx#:~:text=,Star%2094) [\[5\]](https://github.com/verekia/tslfx#:~:text=Early,js%20Shading%20Language%20%28TSL) [\[6\]](https://github.com/verekia/tslfx#:~:text=import%20,from%20%27tslfx) [\[7\]](https://github.com/verekia/tslfx#:~:text=Primitives%20are%20basic%20single%20effects,to%20see%20how%20it%20works) [\[8\]](https://github.com/verekia/tslfx#:~:text=SDFs) [\[9\]](https://github.com/verekia/tslfx#:~:text=Early,js%20Shading%20Language%20%28TSL) [\[10\]](https://github.com/verekia/tslfx#:~:text=The%20effects%20work%20with%20the,js%20or%20any%20other%20wrapper) [\[11\]](https://github.com/verekia/tslfx#:~:text=const%20ImpactVFX%20%3D%20%28%29%20%3D,impact%28%29%2C) [\[77\]](https://github.com/verekia/tslfx#:~:text=MIT%20license) GitHub - verekia/tslfx: ✨ TSLFX • Early-stage collection of VFX, utils, and SDFs for Three.js Shading Language (TSL)

<https://github.com/verekia/tslfx>

[\[14\]](https://discourse.threejs.org/t/what-is-going-on-with-nodematerials-all-the-examples-are-gone/66451#:~:text=gone%20discourse,WebGPURenderer%2C%20with%20a%20heavy) What is going on with NodeMaterials? All the examples are gone

<https://discourse.threejs.org/t/what-is-going-on-with-nodematerials-all-the-examples-are-gone/66451>

[\[15\]](https://github.com/brunosimon/three.js-tsl-template#:~:text=,TSL%20textures%20%28demos) [\[55\]](https://github.com/brunosimon/three.js-tsl-template#:~:text=Three) [\[56\]](https://github.com/brunosimon/three.js-tsl-template#:~:text=Stars) GitHub - brunosimon/three.js-tsl-template

<https://github.com/brunosimon/three.js-tsl-template>

[\[16\]](https://discourse.threejs.org/t/node-editor-for-tsl/76355#:~:text=I%20am%20working%20on%20Node,com%2FBhushanwtf%2Fstatus%2F1877676492509085767%3Ft%3D0lMHj0NQP7u7_GaE1Tngdw%26%20s%3D19) [\[17\]](https://discourse.threejs.org/t/node-editor-for-tsl/76355#:~:text=s%3D19%20x) [\[19\]](https://discourse.threejs.org/t/node-editor-for-tsl/76355#:~:text=bhushan6%20%20March%204%2C%202025%2C,7%3A00am%20%206) Node editor for TSL - Showcase - three.js forum

<https://discourse.threejs.org/t/node-editor-for-tsl/76355>

[\[18\]](https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387#:~:text=Alpha%20release%2C%20hoping%20for%20othr,setup%20in%20the%20image%E2%80%99s%20metadata) [\[22\]](https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387#:~:text=Alpha%20release%2C%20hoping%20for%20othr,setup%20in%20the%20image%E2%80%99s%20metadata) [\[23\]](https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387#:~:text=can%20have%20this%20finished%20faster%21,setup%20in%20the%20image%E2%80%99s%20metadata) [\[24\]](https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387#:~:text=Thanks%20Mr,to%20write%20the%20TSL%20code) [\[25\]](https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387#:~:text=bandinopla%20%20April%201%2C%202025%2C,5%3A14pm%20%207) TSL Visual Node Editor - Alpha Release! - Discussion - three.js forum

<https://discourse.threejs.org/t/tsl-visual-node-editor-alpha-release/80387>

[\[20\]](https://github.com/bandinopla/three.js-visual-node-editor#:~:text=,Star%2048) [\[21\]](https://github.com/bandinopla/three.js-visual-node-editor#:~:text=MIT%20license) GitHub - bandinopla/three.js-visual-node-editor: Visual graph editor for Three TSL

<https://github.com/bandinopla/three.js-visual-node-editor>

[\[26\]](https://discourse.threejs.org/t/three-js-webgpu-post-processing-effects/87390#:~:text=robotbobby%20%20October%2012%2C%202025%2C,2%3A05pm%20%203) Three.js + WebGPU Post-Processing Effects - Resources - three.js forum

<https://discourse.threejs.org/t/three-js-webgpu-post-processing-effects/87390>

[\[30\]](https://discourse.threejs.org/t/how-to-use-custom-shaders-in-webgpu/53343#:~:text=forum%20discourse,bindings%20for%20uniforms%20vertex) How to use custom shaders in WebGPU - Questions - three.js forum

<https://discourse.threejs.org/t/how-to-use-custom-shaders-in-webgpu/53343>

[\[31\]](https://github.com/ektogamat/r3f-webgpu-starter#:~:text=,Star%20185) [\[32\]](https://github.com/ektogamat/r3f-webgpu-starter#:~:text=Image%3A%20screenshot) [\[33\]](https://github.com/ektogamat/r3f-webgpu-starter#:~:text=A%20very%20simple%20scene%20to,See%20the%20demo%20here) GitHub - ektogamat/r3f-webgpu-starter: React Three Fiber WebGPU Post Processing by Anderson Mancini. A very simple scene to demonstrate how to integrate Threejs WebGPU with React Three Fiber using Post Processing effects.

<https://github.com/ektogamat/r3f-webgpu-starter>

[\[34\]](https://www.npmjs.com/package/n8ao?activeTab=dependents#:~:text=n8ao%20,2.0%20perhaps) n8ao - npm

<https://www.npmjs.com/package/n8ao?activeTab=dependents>

[\[35\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=%2F%2F%20%20so%20unaffected%20vertices,count) [\[36\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=Next%2C%20we%E2%80%99ll%20create%20a%20storage,in%20the%20context%20of%20TSL) [\[37\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=The%20effect%20we%E2%80%99re%20going%20to,deformations%20in%20a%20dynamic%20way) [\[38\]](https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/#:~:text=const%20initial_position%20%3D%20storage%28%20text_geo,count) Interactive Text Destruction with Three.js, WebGPU, and TSL | Codrops

<https://tympanus.net/codrops/2025/07/22/interactive-text-destruction-with-three-js-webgpu-and-tsl/>

[\[39\]](https://wawasensei.dev/courses/react-three-fiber/lessons/tsl-gpgpu#:~:text=GPGPU%20particles%20with%20TSL%20%26,TSL%29%20and%20WebGPU) GPGPU particles with TSL & WebGPU - Wawa Sensei

<https://wawasensei.dev/courses/react-three-fiber/lessons/tsl-gpgpu>

[\[40\]](https://lisyarus.github.io/blog/posts/particle-life-simulation-in-browser-using-webgpu.html#:~:text=Particle%20Life%20simulation%20in%20browser,produce%20fun%20simulations%20like%20this) Particle Life simulation in browser using WebGPU - lisyarus blog

<https://lisyarus.github.io/blog/posts/particle-life-simulation-in-browser-using-webgpu.html>

[\[41\]](https://discourse.threejs.org/t/dynamic-batching-using-webgpu/55146#:~:text=forum%20discourse,we%20want%20to%20merging%20meshes) Dynamic Batching using webGPU - Questions - three.js forum

<https://discourse.threejs.org/t/dynamic-batching-using-webgpu/55146>

[\[42\]](https://tympanus.net/codrops/2024/10/30/interactive-3d-with-three-js-batchedmesh-and-webgpurenderer/#:~:text=In%20this%20article%2C%20I%27ll%20walk,processing%20effects) Interactive 3D with Three.js BatchedMesh and WebGPURenderer

<https://tympanus.net/codrops/2024/10/30/interactive-3d-with-three-js-batchedmesh-and-webgpurenderer/>

[\[43\]](https://r3f.docs.pmnd.rs/tutorials/v9-migration-guide#webgpu#:~:text=Recent%20Three,prop%20to%20return%20a%20promise) [\[44\]](https://r3f.docs.pmnd.rs/tutorials/v9-migration-guide#webgpu#:~:text=export%20default%20%28%29%20%3D,meshBasicNodeMaterial) [\[45\]](https://r3f.docs.pmnd.rs/tutorials/v9-migration-guide#webgpu#:~:text=import%20,three%2Ffiber) [\[46\]](https://r3f.docs.pmnd.rs/tutorials/v9-migration-guide#webgpu#:~:text=await%20renderer.init%28%29%20return%20renderer%20%7D%7D,mesh) v9 Migration Guide - React Three Fiber

<https://r3f.docs.pmnd.rs/tutorials/v9-migration-guide>

[\[47\]](https://blog.loopspeed.co.uk/react-three-fiber-webgpu-typescript#:~:text=1) [\[48\]](https://blog.loopspeed.co.uk/react-three-fiber-webgpu-typescript#:~:text=export%20default%20WebGPUCanvas%3B) React Three Fiber with WebGPU and Three Shading Language (TSL) Node Material | Loopspeed

<https://blog.loopspeed.co.uk/react-three-fiber-webgpu-typescript>

[\[49\]](https://github.com/verekia/three-gpu-ecosystem-tests#:~:text=Non) [\[50\]](https://github.com/verekia/three-gpu-ecosystem-tests#:~:text=Top) [\[59\]](https://github.com/verekia/three-gpu-ecosystem-tests#:~:text=This%20is%20a%20collection%20of,React%20Three%20Fiber%2C%20and%20Threlte) [\[60\]](https://github.com/verekia/three-gpu-ecosystem-tests#:~:text=TSL%20node%2C%20and%20a%20test,React%20Three%20Fiber%2C%20and%20Threlte) GitHub - verekia/three-gpu-ecosystem-tests

<https://github.com/verekia/three-gpu-ecosystem-tests>

[\[51\]](https://threlte.xyz/docs/learn/advanced/webgpu#:~:text=To%20use%20the%20Three,replace%20the%20default%20WebGL%20renderer) [\[52\]](https://threlte.xyz/docs/learn/advanced/webgpu#:~:text=import%20,script) [\[53\]](https://threlte.xyz/docs/learn/advanced/webgpu#:~:text=import%20,as%20THREE%20from%20%27three%2Fwebgpu) [\[54\]](https://threlte.xyz/docs/learn/advanced/webgpu#:~:text=The%20WebGPU%20specification%20is%20still,recommend%20using%20WebGPU%20in%20production) WebGPU and TSL | Learn Threlte

<https://threlte.xyz/docs/learn/advanced/webgpu>

[\[57\]](https://github.com/wass08/r3f-webgpu-starter#:~:text=) [\[58\]](https://github.com/wass08/r3f-webgpu-starter#:~:text=React%20Three%20Fiber%20,Starter) GitHub - wass08/r3f-webgpu-starter: Build WebGPU Apps with Three.js & React Three Fiber

<https://github.com/wass08/r3f-webgpu-starter>

[\[61\]](https://nodetoy.co/#:~:text=Built%20for%20ThreeJS%20%26%20React) [\[62\]](https://nodetoy.co/#:~:text=Massive%20toolbox) [\[69\]](https://nodetoy.co/#:~:text=ImageImage) NodeToy | Create and share shader graphs with the world

<https://nodetoy.co/>

[\[63\]](https://github.com/NodeToy/three-nodetoy#:~:text=three) [\[64\]](https://github.com/NodeToy/three-nodetoy#:~:text=import%20,nodetoy) [\[65\]](https://github.com/NodeToy/three-nodetoy#:~:text=Declare%20your%20material%3A) [\[66\]](https://github.com/NodeToy/three-nodetoy#:~:text=Simple%20example%3A) [\[67\]](https://github.com/NodeToy/three-nodetoy#:~:text=If%20your%20materials%20are%20dynamic,for%20more%20information) [\[68\]](https://github.com/NodeToy/three-nodetoy#:~:text=Update%20Time%20%2F%20Dynamic%20uniforms) GitHub - NodeToy/three-nodetoy: <https://three-nodetoy.vercel.app/>

<https://github.com/NodeToy/three-nodetoy>

[\[70\]](https://discourse.threejs.org/t/nodematerial-visual-editor/12479#:~:text=gui%20%20February%203%2C%202020%2C,2%3A16pm%20%202) [\[71\]](https://discourse.threejs.org/t/nodematerial-visual-editor/12479#:~:text=Polygonjs%20also%20has%20a%20visual,is%20heavily%20inspired%20by%20Houdini) NodeMaterial visual editor? - Questions - three.js forum

<https://discourse.threejs.org/t/nodematerial-visual-editor/12479>

[\[72\]](https://github.com/polygonjs/polygonjs#:~:text=Polygonjs) [\[73\]](https://github.com/polygonjs/polygonjs#:~:text=Polygonjs%20helps%20creating%203D%20interactives,web%2C%20without%20having%20to%20code) [\[74\]](https://github.com/polygonjs/polygonjs#:~:text=,nodes%20set%20up%20post%20processing) GitHub - polygonjs/polygonjs: node-based WebGL design tool

<https://github.com/polygonjs/polygonjs>

[\[75\]](https://doc.babylonjs.com/features/featuresDeepDive/materials/node_material/nodeMaterial#:~:text=Node%20Material%20,Node%20Material%20allows%20you) Node Material - Babylon.js Documentation

<https://doc.babylonjs.com/features/featuresDeepDive/materials/node_material/nodeMaterial>